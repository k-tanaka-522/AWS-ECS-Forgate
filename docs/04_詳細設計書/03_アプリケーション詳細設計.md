# アプリケーション詳細設計

> AWS Multi-Account Sample Application
> Transit Gateway による拠点間閉域接続を実現する技術検証・社内デモ用サンプル

---

## ドキュメント情報

| 項目 | 内容 |
|------|------|
| プロジェクト名 | AWS Multi-Account Sample Application |
| 文書バージョン | 1.0 |
| 作成日 | 2025-10-21 |
| 最終更新日 | 2025-10-21 |
| 承認状態 | 承認待ち |

---

## 1. アプリケーション全体構成

### 1.1 モノレポ構成

本プロジェクトは **npm workspaces** を使用したモノレポ構成を採用します。

```
project-root/
├── package.json                 # ルートパッケージ（workspaces定義）
├── packages/
│   ├── public-web/             # Public Web Service
│   ├── admin-dashboard/        # Admin Dashboard
│   ├── batch-processing/       # Batch Processing
│   └── shared/                 # Shared Library
├── infra/                      # CloudFormation（設計書01参照）
└── docs/                       # 設計書
```

### 1.2 技術スタック

| レイヤー | 技術 | バージョン |
|---------|------|----------|
| ランタイム | Node.js | 20.x |
| 言語 | TypeScript | 5.3.x |
| Webフレームワーク | Express.js | 4.18.x |
| バッチフレームワーク | Node.js (native) | - |
| ORMライブラリ | Knex.js | 3.1.x |
| データベース | PostgreSQL | 14.10 |
| コンテナ | Docker | 24.x |
| オーケストレーション | AWS ECS Fargate | - |

### 1.3 参照技術標準

- `.claude/docs/40_standards/42_typescript.md` - TypeScript コーディング規約
- `.claude/docs/40_standards/41_common.md` - 共通コーディング規約
- `.claude/docs/40_standards/49_security.md` - セキュリティ基準

---

## 2. Public Web Service 詳細設計

### 2.1 概要

**目的**: 一般ユーザー向けのWeb API提供

**責務**:
- ユーザー登録・認証
- 商品一覧・検索
- 注文処理

### 2.2 ディレクトリ構成

```
packages/public-web/
├── src/
│   ├── index.ts                      # エントリーポイント（推定50行）
│   ├── app.ts                        # Expressアプリケーション設定（推定120行）
│   ├── config/
│   │   ├── database.ts              # DB接続設定（推定80行）
│   │   └── secrets.ts               # Secrets Manager連携（推定60行）
│   ├── api/                         # API層
│   │   ├── routes/
│   │   │   ├── index.ts             # ルート集約（推定40行）
│   │   │   ├── users.routes.ts      # ユーザーAPI（推定80行）
│   │   │   ├── products.routes.ts   # 商品API（推定100行）
│   │   │   └── orders.routes.ts     # 注文API（推定120行）
│   │   ├── controllers/
│   │   │   ├── users.controller.ts  # ユーザー操作（推定180行）
│   │   │   ├── products.controller.ts # 商品操作（推定150行）
│   │   │   └── orders.controller.ts # 注文操作（推定200行）
│   │   └── middleware/
│   │       ├── auth.middleware.ts   # 認証ミドルウェア（推定100行）
│   │       ├── error.middleware.ts  # エラーハンドリング（推定80行）
│   │       └── validation.middleware.ts # バリデーション（推定120行）
│   ├── domain/                      # ドメイン層
│   │   ├── services/
│   │   │   ├── user.service.ts      # ユーザービジネスロジック（推定220行）
│   │   │   ├── product.service.ts   # 商品ビジネスロジック（推定180行）
│   │   │   └── order.service.ts     # 注文ビジネスロジック（推定250行）
│   │   ├── entities/
│   │   │   ├── user.entity.ts       # Userエンティティ（推定100行）
│   │   │   ├── product.entity.ts    # Productエンティティ（推定90行）
│   │   │   └── order.entity.ts      # Orderエンティティ（推定110行）
│   │   └── value-objects/
│   │       ├── email.vo.ts          # Email値オブジェクト（推定60行）
│   │       └── money.vo.ts          # Money値オブジェクト（推定70行）
│   └── infrastructure/              # インフラ層
│       └── repositories/
│           ├── user.repository.ts   # ユーザーDB操作（推定180行）
│           ├── product.repository.ts # 商品DB操作（推定150行）
│           └── order.repository.ts  # 注文DB操作（推定200行）
├── tests/
│   ├── unit/                        # 単体テスト（推定800行）
│   └── integration/                 # 結合テスト（推定600行）
├── Dockerfile                       # コンテナイメージ（推定40行）
├── package.json                     # 依存関係定義（推定60行）
└── tsconfig.json                    # TypeScript設定（推定50行）
```

**推定総行数**: 約4,200行（テスト含む）

### 2.3 API設計

#### 2.3.1 ユーザーAPI

**POST /api/v1/users/register**

```typescript
// Request Body
interface RegisterUserRequest {
  email: string;      // 必須、メール形式
  name: string;       // 必須、1-255文字
  password: string;   // 必須、8文字以上
}

// Response (201 Created)
interface RegisterUserResponse {
  userId: string;     // UUID
  email: string;
  name: string;
  createdAt: string;  // ISO 8601
}

// Error Response (400 Bad Request)
interface ErrorResponse {
  error: {
    code: string;     // "VALIDATION_ERROR"
    message: string;
    details: Array<{
      field: string;
      reason: string;
    }>;
  };
}
```

**POST /api/v1/users/login**

```typescript
// Request Body
interface LoginUserRequest {
  email: string;
  password: string;
}

// Response (200 OK)
interface LoginUserResponse {
  token: string;      // JWT トークン
  expiresIn: number;  // 有効期限（秒）
}
```

#### 2.3.2 商品API

**GET /api/v1/products**

```typescript
// Query Parameters
interface GetProductsQuery {
  page?: number;      // デフォルト: 1
  limit?: number;     // デフォルト: 20、最大: 100
  sort?: 'price_asc' | 'price_desc' | 'newest';
}

// Response (200 OK)
interface GetProductsResponse {
  products: Array<{
    productId: string;
    name: string;
    description: string;
    price: number;
    stockQuantity: number;
  }>;
  pagination: {
    currentPage: number;
    totalPages: number;
    totalItems: number;
  };
}
```

**GET /api/v1/products/:productId**

```typescript
// Response (200 OK)
interface GetProductResponse {
  productId: string;
  name: string;
  description: string;
  price: number;
  stockQuantity: number;
  createdAt: string;
  updatedAt: string;
}
```

#### 2.3.3 注文API

**POST /api/v1/orders**

```typescript
// Request Body (認証必須)
interface CreateOrderRequest {
  items: Array<{
    productId: string;
    quantity: number;  // 1以上
  }>;
}

// Response (201 Created)
interface CreateOrderResponse {
  orderId: string;
  userId: string;
  totalAmount: number;
  status: 'pending' | 'completed' | 'cancelled';
  items: Array<{
    orderItemId: string;
    productId: string;
    productName: string;
    quantity: number;
    price: number;
  }>;
  createdAt: string;
}
```

**GET /api/v1/orders/:orderId**

```typescript
// Response (200 OK) - 認証必須、本人のみ
interface GetOrderResponse {
  orderId: string;
  userId: string;
  totalAmount: number;
  status: 'pending' | 'completed' | 'cancelled';
  items: Array<{
    orderItemId: string;
    productId: string;
    productName: string;
    quantity: number;
    price: number;
  }>;
  createdAt: string;
  updatedAt: string;
}
```

### 2.4 認証設計

**方式**: JWT (JSON Web Token)

**フロー**:
1. ユーザーが `/api/v1/users/login` でメール・パスワードを送信
2. サーバーが bcrypt でパスワードを検証
3. 検証成功時、JWT トークンを発行（有効期限: 24時間）
4. クライアントは以降のリクエストで `Authorization: Bearer <token>` ヘッダーを付与

**JWT ペイロード**:
```typescript
interface JWTPayload {
  userId: string;
  email: string;
  iat: number;  // 発行時刻
  exp: number;  // 有効期限
}
```

**実装方針**:
- ライブラリ: `jsonwebtoken`
- 秘密鍵: AWS Secrets Manager から取得
- アルゴリズム: HS256

### 2.5 エラーハンドリング

**統一エラーレスポンス形式**:

```typescript
interface ErrorResponse {
  error: {
    code: string;        // エラーコード（例: "VALIDATION_ERROR"）
    message: string;     // ユーザー向けメッセージ
    details?: any;       // 詳細情報（オプション）
    requestId: string;   // リクエストID（ログ追跡用）
  };
}
```

**エラーコード一覧**:

| HTTPステータス | エラーコード | 説明 |
|--------------|-------------|------|
| 400 | VALIDATION_ERROR | バリデーションエラー |
| 401 | UNAUTHORIZED | 認証失敗 |
| 403 | FORBIDDEN | 権限不足 |
| 404 | NOT_FOUND | リソースが存在しない |
| 409 | CONFLICT | データ競合（例: メール重複） |
| 500 | INTERNAL_ERROR | サーバー内部エラー |

---

## 3. Admin Dashboard 詳細設計

### 3.1 概要

**目的**: 管理者向けのデータ管理・監視ツール

**責務**:
- 商品マスタ管理（CRUD）
- 注文管理（ステータス変更）
- ユーザー管理（検索・参照）

### 3.2 ディレクトリ構成

```
packages/admin-dashboard/
├── src/
│   ├── index.ts                      # エントリーポイント（推定50行）
│   ├── app.ts                        # Expressアプリケーション設定（推定100行）
│   ├── config/
│   │   └── database.ts              # DB接続設定（推定80行）
│   ├── api/
│   │   ├── routes/
│   │   │   ├── index.ts             # ルート集約（推定30行）
│   │   │   ├── products.routes.ts   # 商品管理API（推定120行）
│   │   │   ├── orders.routes.ts     # 注文管理API（推定100行）
│   │   │   └── users.routes.ts      # ユーザー管理API（推定80行）
│   │   ├── controllers/
│   │   │   ├── products.controller.ts # 商品操作（推定200行）
│   │   │   ├── orders.controller.ts # 注文操作（推定180行）
│   │   │   └── users.controller.ts  # ユーザー操作（推定150行）
│   │   └── middleware/
│   │       ├── auth.middleware.ts   # 管理者認証（推定80行）
│   │       └── error.middleware.ts  # エラーハンドリング（推定70行）
│   ├── domain/
│   │   └── services/
│   │       ├── product-admin.service.ts # 商品管理ロジック（推定220行）
│   │       ├── order-admin.service.ts   # 注文管理ロジック（推定200行）
│   │       └── user-admin.service.ts    # ユーザー管理ロジック（推定180行）
│   └── infrastructure/
│       └── repositories/
│           # shared パッケージのリポジトリを再利用
├── tests/                           # テスト（推定600行）
├── Dockerfile                       # コンテナイメージ（推定40行）
├── package.json                     # 依存関係定義（推定50行）
└── tsconfig.json                    # TypeScript設定（推定50行）
```

**推定総行数**: 約2,600行（テスト含む）

### 3.3 API設計

#### 3.3.1 商品管理API

**POST /api/v1/admin/products**

```typescript
// Request Body (管理者認証必須)
interface CreateProductRequest {
  name: string;           // 必須、1-255文字
  description: string;    // 必須、1-1000文字
  price: number;          // 必須、0以上
  stockQuantity: number;  // 必須、0以上
}

// Response (201 Created)
interface CreateProductResponse {
  productId: string;
  name: string;
  description: string;
  price: number;
  stockQuantity: number;
  createdAt: string;
}
```

**PUT /api/v1/admin/products/:productId**

```typescript
// Request Body (管理者認証必須)
interface UpdateProductRequest {
  name?: string;
  description?: string;
  price?: number;
  stockQuantity?: number;
}

// Response (200 OK)
interface UpdateProductResponse {
  productId: string;
  name: string;
  description: string;
  price: number;
  stockQuantity: number;
  updatedAt: string;
}
```

**DELETE /api/v1/admin/products/:productId**

```typescript
// Response (204 No Content)
```

#### 3.3.2 注文管理API

**PATCH /api/v1/admin/orders/:orderId/status**

```typescript
// Request Body (管理者認証必須)
interface UpdateOrderStatusRequest {
  status: 'pending' | 'completed' | 'cancelled';
}

// Response (200 OK)
interface UpdateOrderStatusResponse {
  orderId: string;
  status: string;
  updatedAt: string;
}
```

**GET /api/v1/admin/orders**

```typescript
// Query Parameters
interface GetOrdersQuery {
  page?: number;
  limit?: number;
  status?: 'pending' | 'completed' | 'cancelled';
  userId?: string;
}

// Response (200 OK)
interface GetOrdersResponse {
  orders: Array<{
    orderId: string;
    userId: string;
    userEmail: string;
    totalAmount: number;
    status: string;
    createdAt: string;
  }>;
  pagination: {
    currentPage: number;
    totalPages: number;
    totalItems: number;
  };
}
```

### 3.4 認証設計

**方式**: Basic認証（PoC用、本番環境では OAuth 2.0 推奨）

**フロー**:
1. クライアントが `Authorization: Basic <base64(username:password)>` ヘッダーを送信
2. サーバーが環境変数 `ADMIN_USERNAME`、`ADMIN_PASSWORD` と照合
3. 一致すればアクセス許可

**実装方針**:
- 認証情報は AWS Secrets Manager で管理
- ミドルウェアで全ての `/api/v1/admin/*` エンドポイントを保護

---

## 4. Batch Processing 詳細設計

### 4.1 概要

**目的**: 定期実行バッチ処理

**責務**:
- 在庫不足アラート（毎日 AM 9:00 JST）
- 注文統計レポート生成（毎週月曜 AM 10:00 JST）

### 4.2 ディレクトリ構成

```
packages/batch-processing/
├── src/
│   ├── jobs/
│   │   ├── stock-alert.job.ts       # 在庫不足アラート（推定150行）
│   │   └── order-report.job.ts      # 注文統計レポート（推定180行）
│   ├── config/
│   │   └── database.ts              # DB接続設定（推定80行）
│   └── utils/
│       ├── logger.ts                # ロガー（推定60行）
│       └── notification.ts          # 通知ヘルパー（推定80行）
├── tests/                           # テスト（推定300行）
├── Dockerfile                       # コンテナイメージ（推定40行）
├── package.json                     # 依存関係定義（推定50行）
└── tsconfig.json                    # TypeScript設定（推定50行）
```

**推定総行数**: 約990行（テスト含む）

### 4.3 バッチジョブ設計

#### 4.3.1 在庫不足アラート

**実行タイミング**: 毎日 AM 9:00 JST（ECS Scheduled Task）

**処理フロー**:
1. `products` テーブルから `stock_quantity < 10` の商品を取得
2. CloudWatch Logs にアラート出力
3. （将来拡張）SNS Topic にメール通知

**実装例**:

```typescript
// src/jobs/stock-alert.job.ts
import { Knex } from 'knex';
import { getDbConnection } from '../config/database';
import { logger } from '../utils/logger';

interface LowStockProduct {
  productId: string;
  name: string;
  stockQuantity: number;
}

export async function runStockAlert(): Promise<void> {
  const db: Knex = await getDbConnection();

  try {
    logger.info('Starting stock alert job...');

    const lowStockProducts: LowStockProduct[] = await db('products')
      .select('product_id as productId', 'name', 'stock_quantity as stockQuantity')
      .where('stock_quantity', '<', 10)
      .orderBy('stock_quantity', 'asc');

    if (lowStockProducts.length === 0) {
      logger.info('No low stock products found.');
      return;
    }

    logger.warn(`Found ${lowStockProducts.length} low stock products:`, {
      products: lowStockProducts,
    });

    // 将来拡張: SNS Topic に通知
    // await notifySlack('Low stock alert', lowStockProducts);

    logger.info('Stock alert job completed.');
  } catch (error) {
    logger.error('Stock alert job failed:', error);
    throw error;
  } finally {
    await db.destroy();
  }
}

// エントリーポイント
if (require.main === module) {
  runStockAlert()
    .then(() => process.exit(0))
    .catch((error) => {
      logger.error('Fatal error:', error);
      process.exit(1);
    });
}
```

#### 4.3.2 注文統計レポート

**実行タイミング**: 毎週月曜 AM 10:00 JST（ECS Scheduled Task）

**処理フロー**:
1. 過去7日間の注文データを集計
2. 以下の統計を算出:
   - 総注文数
   - 総売上金額
   - 平均注文金額
   - 人気商品TOP5
3. CloudWatch Logs に出力

**実装例**:

```typescript
// src/jobs/order-report.job.ts
import { Knex } from 'knex';
import { getDbConnection } from '../config/database';
import { logger } from '../utils/logger';

interface OrderStats {
  totalOrders: number;
  totalRevenue: number;
  averageOrderValue: number;
  topProducts: Array<{
    productId: string;
    productName: string;
    totalQuantity: number;
    totalRevenue: number;
  }>;
}

export async function runOrderReport(): Promise<void> {
  const db: Knex = await getDbConnection();

  try {
    logger.info('Starting order report job...');

    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    // 総注文数・総売上
    const [orderSummary] = await db('orders')
      .where('created_at', '>=', sevenDaysAgo)
      .count('order_id as totalOrders')
      .sum('total_amount as totalRevenue');

    const totalOrders = Number(orderSummary.totalOrders);
    const totalRevenue = Number(orderSummary.totalRevenue) || 0;
    const averageOrderValue = totalOrders > 0 ? totalRevenue / totalOrders : 0;

    // 人気商品TOP5
    const topProducts = await db('order_items as oi')
      .join('orders as o', 'oi.order_id', 'o.order_id')
      .join('products as p', 'oi.product_id', 'p.product_id')
      .where('o.created_at', '>=', sevenDaysAgo)
      .groupBy('p.product_id', 'p.name')
      .select(
        'p.product_id as productId',
        'p.name as productName',
        db.raw('SUM(oi.quantity) as totalQuantity'),
        db.raw('SUM(oi.price * oi.quantity) as totalRevenue')
      )
      .orderBy('totalRevenue', 'desc')
      .limit(5);

    const stats: OrderStats = {
      totalOrders,
      totalRevenue,
      averageOrderValue,
      topProducts,
    };

    logger.info('Order report (last 7 days):', stats);

    logger.info('Order report job completed.');
  } catch (error) {
    logger.error('Order report job failed:', error);
    throw error;
  } finally {
    await db.destroy();
  }
}

// エントリーポイント
if (require.main === module) {
  runOrderReport()
    .then(() => process.exit(0))
    .catch((error) => {
      logger.error('Fatal error:', error);
      process.exit(1);
    });
}
```

### 4.4 ECS Scheduled Task 設定

**CloudFormation 設計書 (01_CloudFormation詳細設計.md) 参照**:

- 在庫不足アラート: `cron(0 0 * * ? *)` (毎日 AM 9:00 JST = UTC 0:00)
- 注文統計レポート: `cron(0 1 ? * MON *)` (毎週月曜 AM 10:00 JST = UTC 1:00)

---

## 5. Shared Library 詳細設計

### 5.1 概要

**目的**: 共通ロジック・型定義の再利用

**責務**:
- データベースリポジトリ（CRUD操作）
- エンティティ・型定義
- ユーティリティ関数

### 5.2 ディレクトリ構成

```
packages/shared/
├── src/
│   ├── index.ts                     # エクスポート集約（推定80行）
│   ├── entities/
│   │   ├── user.entity.ts           # Userエンティティ（推定100行）
│   │   ├── product.entity.ts        # Productエンティティ（推定90行）
│   │   ├── order.entity.ts          # Orderエンティティ（推定110行）
│   │   └── order-item.entity.ts     # OrderItemエンティティ（推定80行）
│   ├── repositories/
│   │   ├── base.repository.ts       # 基底リポジトリ（推定120行）
│   │   ├── user.repository.ts       # ユーザーDB操作（推定180行）
│   │   ├── product.repository.ts    # 商品DB操作（推定150行）
│   │   ├── order.repository.ts      # 注文DB操作（推定200行）
│   │   └── order-item.repository.ts # 注文明細DB操作（推定140行）
│   ├── value-objects/
│   │   ├── email.vo.ts              # Email値オブジェクト（推定60行）
│   │   └── money.vo.ts              # Money値オブジェクト（推定70行）
│   ├── config/
│   │   └── database.ts              # DB接続設定（推定100行）
│   └── utils/
│       ├── logger.ts                # ロガー（推定80行）
│       └── validator.ts             # バリデーター（推定100行）
├── tests/                           # テスト（推定700行）
├── package.json                     # 依存関係定義（推定50行）
└── tsconfig.json                    # TypeScript設定（推定50行）
```

**推定総行数**: 約2,410行（テスト含む）

### 5.3 エンティティ設計

#### 5.3.1 User Entity

```typescript
// src/entities/user.entity.ts
export interface User {
  userId: string;
  email: string;
  name: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateUserDto {
  email: string;
  name: string;
  passwordHash: string;
}

export interface UpdateUserDto {
  email?: string;
  name?: string;
}
```

#### 5.3.2 Product Entity

```typescript
// src/entities/product.entity.ts
export interface Product {
  productId: string;
  name: string;
  description: string;
  price: number;
  stockQuantity: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateProductDto {
  name: string;
  description: string;
  price: number;
  stockQuantity: number;
}

export interface UpdateProductDto {
  name?: string;
  description?: string;
  price?: number;
  stockQuantity?: number;
}
```

#### 5.3.3 Order Entity

```typescript
// src/entities/order.entity.ts
export type OrderStatus = 'pending' | 'completed' | 'cancelled';

export interface Order {
  orderId: string;
  userId: string;
  totalAmount: number;
  status: OrderStatus;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateOrderDto {
  userId: string;
  totalAmount: number;
  status: OrderStatus;
}

export interface UpdateOrderDto {
  status?: OrderStatus;
  totalAmount?: number;
}
```

#### 5.3.4 OrderItem Entity

```typescript
// src/entities/order-item.entity.ts
export interface OrderItem {
  orderItemId: string;
  orderId: string;
  productId: string;
  quantity: number;
  price: number;
}

export interface CreateOrderItemDto {
  orderId: string;
  productId: string;
  quantity: number;
  price: number;
}
```

### 5.4 リポジトリ設計

#### 5.4.1 Base Repository

```typescript
// src/repositories/base.repository.ts
import { Knex } from 'knex';

export abstract class BaseRepository<T> {
  protected db: Knex;
  protected tableName: string;

  constructor(db: Knex, tableName: string) {
    this.db = db;
    this.tableName = tableName;
  }

  async findById(id: string): Promise<T | null> {
    const row = await this.db(this.tableName).where({ id }).first();
    return row ? this.mapToEntity(row) : null;
  }

  async findAll(limit: number = 100, offset: number = 0): Promise<T[]> {
    const rows = await this.db(this.tableName).limit(limit).offset(offset);
    return rows.map((row) => this.mapToEntity(row));
  }

  async create(data: Partial<T>): Promise<T> {
    const [row] = await this.db(this.tableName).insert(data).returning('*');
    return this.mapToEntity(row);
  }

  async update(id: string, data: Partial<T>): Promise<T | null> {
    const [row] = await this.db(this.tableName)
      .where({ id })
      .update({ ...data, updated_at: this.db.fn.now() })
      .returning('*');
    return row ? this.mapToEntity(row) : null;
  }

  async delete(id: string): Promise<boolean> {
    const result = await this.db(this.tableName).where({ id }).del();
    return result > 0;
  }

  protected abstract mapToEntity(row: any): T;
}
```

#### 5.4.2 User Repository

```typescript
// src/repositories/user.repository.ts
import { Knex } from 'knex';
import { BaseRepository } from './base.repository';
import { User, CreateUserDto } from '../entities/user.entity';

export class UserRepository extends BaseRepository<User> {
  constructor(db: Knex) {
    super(db, 'users');
  }

  async findByEmail(email: string): Promise<User | null> {
    const row = await this.db(this.tableName).where({ email }).first();
    return row ? this.mapToEntity(row) : null;
  }

  async createUser(dto: CreateUserDto): Promise<User> {
    const [row] = await this.db(this.tableName)
      .insert({
        email: dto.email,
        name: dto.name,
        password_hash: dto.passwordHash,
      })
      .returning('*');
    return this.mapToEntity(row);
  }

  protected mapToEntity(row: any): User {
    return {
      userId: row.user_id,
      email: row.email,
      name: row.name,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
    };
  }
}
```

#### 5.4.3 Product Repository

```typescript
// src/repositories/product.repository.ts
import { Knex } from 'knex';
import { BaseRepository } from './base.repository';
import { Product } from '../entities/product.entity';

export class ProductRepository extends BaseRepository<Product> {
  constructor(db: Knex) {
    super(db, 'products');
  }

  async findLowStock(threshold: number = 10): Promise<Product[]> {
    const rows = await this.db(this.tableName)
      .where('stock_quantity', '<', threshold)
      .orderBy('stock_quantity', 'asc');
    return rows.map((row) => this.mapToEntity(row));
  }

  protected mapToEntity(row: any): Product {
    return {
      productId: row.product_id,
      name: row.name,
      description: row.description,
      price: parseFloat(row.price),
      stockQuantity: row.stock_quantity,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
    };
  }
}
```

#### 5.4.4 Order Repository

```typescript
// src/repositories/order.repository.ts
import { Knex } from 'knex';
import { BaseRepository } from './base.repository';
import { Order, OrderStatus } from '../entities/order.entity';

export class OrderRepository extends BaseRepository<Order> {
  constructor(db: Knex) {
    super(db, 'orders');
  }

  async findByUserId(userId: string, limit: number = 20): Promise<Order[]> {
    const rows = await this.db(this.tableName)
      .where({ user_id: userId })
      .orderBy('created_at', 'desc')
      .limit(limit);
    return rows.map((row) => this.mapToEntity(row));
  }

  async findByStatus(status: OrderStatus, limit: number = 100): Promise<Order[]> {
    const rows = await this.db(this.tableName)
      .where({ status })
      .orderBy('created_at', 'desc')
      .limit(limit);
    return rows.map((row) => this.mapToEntity(row));
  }

  protected mapToEntity(row: any): Order {
    return {
      orderId: row.order_id,
      userId: row.user_id,
      totalAmount: parseFloat(row.total_amount),
      status: row.status as OrderStatus,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
    };
  }
}
```

### 5.5 データベース接続設定

```typescript
// src/config/database.ts
import knex, { Knex } from 'knex';
import { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';

interface DbConfig {
  host: string;
  port: number;
  database: string;
  user: string;
  password: string;
}

async function getDbPassword(): Promise<string> {
  const secretName = process.env.DB_SECRET_ARN;
  if (!secretName) {
    throw new Error('DB_SECRET_ARN environment variable is not set');
  }

  const client = new SecretsManagerClient({ region: process.env.AWS_REGION || 'ap-northeast-1' });
  const command = new GetSecretValueCommand({ SecretId: secretName });
  const response = await client.send(command);

  if (!response.SecretString) {
    throw new Error('Secret value not found');
  }

  const secret = JSON.parse(response.SecretString);
  return secret.password;
}

export async function getDbConnection(): Promise<Knex> {
  const password = await getDbPassword();

  const config: DbConfig = {
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '5432', 10),
    database: process.env.DB_NAME || 'sampledb',
    user: process.env.DB_USER || 'postgres',
    password,
  };

  return knex({
    client: 'pg',
    connection: config,
    pool: {
      min: 2,
      max: 10,
    },
  });
}
```

---

## 6. Docker イメージ設計

### 6.1 共通 Dockerfile パターン

各パッケージで共通の Dockerfile 構成を使用します。

```dockerfile
# packages/public-web/Dockerfile
FROM node:20-alpine AS builder

WORKDIR /app

# ルートの package.json をコピー（workspaces定義用）
COPY package*.json ./
COPY packages/public-web/package*.json ./packages/public-web/
COPY packages/shared/package*.json ./packages/shared/

# 依存関係インストール
RUN npm ci --workspaces

# ソースコードコピー
COPY packages/public-web ./packages/public-web
COPY packages/shared ./packages/shared

# ビルド
RUN npm run build --workspace=packages/public-web

# 本番環境イメージ
FROM node:20-alpine

WORKDIR /app

# 必要なファイルのみコピー
COPY --from=builder /app/packages/public-web/dist ./dist
COPY --from=builder /app/packages/public-web/package*.json ./
COPY --from=builder /app/node_modules ./node_modules

# 非rootユーザーで実行
RUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001
USER nodejs

EXPOSE 3000

CMD ["node", "dist/index.js"]
```

**推定行数**: 約40行（各パッケージで同様）

### 6.2 イメージサイズ最適化

**戦略**:
- マルチステージビルドでビルド依存関係を除外
- Alpine Linuxベースイメージ使用（約50MB）
- `.dockerignore` で不要ファイルを除外

```
# .dockerignore
node_modules
dist
*.log
.env
.git
tests
*.md
```

---

## 7. 環境変数設計

### 7.1 Public Web Service

```bash
# Runtime
NODE_ENV=production
PORT=3000
LOG_LEVEL=info

# Database
DB_HOST=<RDS Endpoint>
DB_PORT=5432
DB_NAME=sampledb
DB_USER=appuser
DB_SECRET_ARN=<Secrets Manager ARN>

# JWT
JWT_SECRET_ARN=<Secrets Manager ARN>
JWT_EXPIRES_IN=86400  # 24時間（秒）

# AWS
AWS_REGION=ap-northeast-1
```

### 7.2 Admin Dashboard

```bash
# Runtime
NODE_ENV=production
PORT=3001
LOG_LEVEL=info

# Database
DB_HOST=<RDS Endpoint>
DB_PORT=5432
DB_NAME=sampledb
DB_USER=appuser
DB_SECRET_ARN=<Secrets Manager ARN>

# Admin Auth
ADMIN_SECRET_ARN=<Secrets Manager ARN>

# AWS
AWS_REGION=ap-northeast-1
```

### 7.3 Batch Processing

```bash
# Runtime
NODE_ENV=production
LOG_LEVEL=info

# Database
DB_HOST=<RDS Endpoint>
DB_PORT=5432
DB_NAME=sampledb
DB_USER=appuser
DB_SECRET_ARN=<Secrets Manager ARN>

# AWS
AWS_REGION=ap-northeast-1
```

**機密情報管理**:
- すべての機密情報（DB_SECRET_ARN等）は AWS Secrets Manager で管理
- ECS Task Definition で環境変数として注入

---

## 8. ログ設計

### 8.1 ログレベル

| レベル | 用途 | 例 |
|-------|------|-----|
| ERROR | エラー・例外 | DB接続失敗、未ハンドル例外 |
| WARN | 警告 | 在庫不足、リトライ発生 |
| INFO | 通常動作 | リクエスト受信、バッチ開始/完了 |
| DEBUG | デバッグ情報 | SQL実行内容、変数値 |

### 8.2 ログ形式

**JSON形式** で CloudWatch Logs に出力

```json
{
  "timestamp": "2025-10-21T12:34:56.789Z",
  "level": "INFO",
  "service": "public-web",
  "message": "User registered successfully",
  "context": {
    "userId": "550e8400-e29b-41d4-a716-446655440000",
    "email": "user@example.com",
    "requestId": "abc-123-def"
  }
}
```

### 8.3 CloudWatch Logs 設計

**ロググループ構成**:
- `/ecs/sample-app/public-web` - Public Web Service
- `/ecs/sample-app/admin-dashboard` - Admin Dashboard
- `/ecs/sample-app/batch-processing` - Batch Processing

**保持期間**: 30日（PoC用、本番環境では90日以上推奨）

---

## 9. セキュリティ設計

### 9.1 認証・認可

| サービス | 認証方式 | 認可方式 |
|---------|---------|---------|
| Public Web | JWT | ユーザーID検証（本人のみ） |
| Admin Dashboard | Basic認証 | 管理者ロール（全データアクセス可） |
| Batch Processing | なし | VPC内部のみアクセス可 |

### 9.2 データ暗号化

**転送時**: TLS 1.3（ALB終端）

**保管時**:
- RDS: KMS暗号化（設計書02参照）
- Secrets Manager: デフォルトKMS暗号化

### 9.3 パスワードハッシュ化

**ライブラリ**: bcrypt

**ソルトラウンド**: 10

```typescript
import bcrypt from 'bcrypt';

// ハッシュ化
const passwordHash = await bcrypt.hash(password, 10);

// 検証
const isValid = await bcrypt.compare(password, passwordHash);
```

### 9.4 SQLインジェクション対策

**対策**: Knex.js のプレースホルダー使用

```typescript
// ❌ Bad: 文字列結合
const result = await db.raw(`SELECT * FROM users WHERE email = '${email}'`);

// ✅ Good: プレースホルダー
const result = await db('users').where({ email });
```

### 9.5 XSS対策

**対策**:
- APIはJSONのみ返却（HTMLは返さない）
- フロントエンド側でサニタイズ（React等のフレームワーク使用時）

### 9.6 CSRF対策

**対策**:
- APIはCookieベース認証を使用しない（JWTトークン方式）
- SameSite属性設定（将来Cookieを使う場合）

---

## 10. 実装方針

### 10.1 ファイル分割方針

**基本原則**:
- 1ファイル = 1責務（Single Responsibility Principle）
- 1ファイル300行以内を目標
- 層別分割（API層、ドメイン層、インフラ層）

**例外**:
- 以下のファイルは300行を超える可能性がありますが、責務の凝集性を考慮し許容します：
  - `order.service.ts` (推定250行) - 注文ビジネスロジック
  - `user.controller.ts` (推定180行) - ユーザーAPI操作
  - `product-admin.service.ts` (推定220行) - 商品管理ロジック

### 10.2 ディレクトリ構成

**採用パターン**: レイヤードアーキテクチャ

```
src/
├── api/               # API層（ルート、コントローラー、ミドルウェア）
├── domain/            # ドメイン層（ビジネスロジック、エンティティ）
├── infrastructure/    # インフラ層（DB、外部API）
└── config/            # 設定ファイル
```

**参照技術標準**: `.claude/docs/40_standards/42_typescript.md`

### 10.3 モジュール分割

#### Public Web Service

| レイヤー | ファイル数 | 推定総行数 |
|---------|-----------|-----------|
| API層 | 10ファイル | 約1,000行 |
| ドメイン層 | 8ファイル | 約1,100行 |
| インフラ層 | 3ファイル | 約530行 |
| 設定・エントリーポイント | 4ファイル | 約310行 |
| **合計** | **25ファイル** | **約2,940行** |

#### Admin Dashboard

| レイヤー | ファイル数 | 推定総行数 |
|---------|-----------|-----------|
| API層 | 7ファイル | 約660行 |
| ドメイン層 | 3ファイル | 約600行 |
| 設定・エントリーポイント | 3ファイル | 約230行 |
| **合計** | **13ファイル** | **約1,490行** |

#### Batch Processing

| レイヤー | ファイル数 | 推定総行数 |
|---------|-----------|-----------|
| ジョブ | 2ファイル | 約330行 |
| 設定・ユーティリティ | 3ファイル | 約220行 |
| **合計** | **5ファイル** | **約550行** |

#### Shared Library

| レイヤー | ファイル数 | 推定総行数 |
|---------|-----------|-----------|
| エンティティ | 4ファイル | 約380行 |
| リポジトリ | 5ファイル | 約790行 |
| 値オブジェクト | 2ファイル | 約130行 |
| 設定・ユーティリティ | 4ファイル | 約330行 |
| **合計** | **15ファイル** | **約1,630行** |

### 10.4 命名規則

**TypeScript**:
- ファイル名: kebab-case (`user-service.ts`)
- クラス名: PascalCase (`UserService`)
- 関数名: camelCase (`getUserById`)
- インターフェース名: PascalCase (`CreateUserRequest`)
- 型エイリアス: PascalCase (`OrderStatus`)

**データベース**:
- テーブル名: snake_case 複数形 (`users`, `order_items`)
- カラム名: snake_case (`user_id`, `created_at`)

**参照技術標準**: `.claude/docs/40_standards/42_typescript.md`

### 10.5 技術標準の適用

**参照する技術標準**:
- `.claude/docs/40_standards/41_common.md` - 共通コーディング規約
- `.claude/docs/40_standards/42_typescript.md` - TypeScript規約
- `.claude/docs/40_standards/49_security.md` - セキュリティ基準

**プロジェクト固有の例外**:
- なし（全て技術標準に準拠）

### 10.6 テスト方針

**カバレッジ目標**:
- 単体テスト: 70%以上
- 結合テスト: 主要APIエンドポイント100%

**テストフレームワーク**:
- Jest（単体テスト、結合テスト）
- Supertest（API結合テスト）

**テストファイル配置**:
```
tests/
├── unit/
│   ├── domain/
│   │   └── user.service.test.ts
│   └── infrastructure/
│       └── user.repository.test.ts
└── integration/
    └── api/
        └── users.api.test.ts
```

### 10.7 実装時の注意事項

1. **各ファイル作成前に推定行数を再確認**
   - 300行を超える場合、さらに分割できないか検討

2. **技術標準との整合性を確認**
   - ESLint、Prettier設定を技術標準に合わせる

3. **セキュリティチェック**
   - Secrets Managerから機密情報を取得しているか
   - SQLインジェクション対策（Knex.jsプレースホルダー）
   - パスワードハッシュ化（bcrypt）

4. **不明点があれば設計者に確認**
   - 設計書に記載のない仕様が発生した場合、必ず確認

---

## 11. パフォーマンス設計

### 11.1 データベースクエリ最適化

**方針**:
- N+1問題を避ける（JOIN活用）
- インデックス活用（設計書02参照）
- ページネーション実装（limit/offset）

**例**:
```typescript
// ❌ Bad: N+1問題
const orders = await db('orders').select('*');
for (const order of orders) {
  order.items = await db('order_items').where({ order_id: order.order_id });
}

// ✅ Good: JOIN
const orders = await db('orders as o')
  .leftJoin('order_items as oi', 'o.order_id', 'oi.order_id')
  .select('o.*', 'oi.*');
```

### 11.2 コネクションプール設定

**Knex.js設定**:
```typescript
{
  pool: {
    min: 2,    // 最小接続数
    max: 10,   // 最大接続数
  },
}
```

**考慮事項**:
- ECS Fargate タスク数 × max = RDS最大接続数
- RDS PostgreSQL デフォルト最大接続数: 100

### 11.3 メモリ使用量

**ECS Fargate タスク設定**:
- CPU: 0.25 vCPU
- メモリ: 512 MB

**Node.js メモリ制限**:
```bash
NODE_OPTIONS=--max-old-space-size=450  # 450MB（余裕を持たせる）
```

---

## 12. 監視・アラート設計

**詳細は設計書04（監視詳細設計.md）を参照**

**主要メトリクス**:
- ECS CPU使用率
- ECS メモリ使用率
- ALB ターゲット正常性
- RDS 接続数
- API レスポンスタイム
- エラー率

---

## 変更履歴

| 日付 | 版数 | 変更内容 | 承認者 |
|------|------|----------|--------|
| 2025-10-21 | 1.0 | 初版作成 | - |
