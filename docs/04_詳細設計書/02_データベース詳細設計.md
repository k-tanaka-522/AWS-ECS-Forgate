# データベース詳細設計

> AWS Multi-Account Sample Application - Database Design

---

## 1. はじめに

### 1.1 本ドキュメントの目的

本書は、AWS Multi-Account Sample ApplicationのRDS PostgreSQL詳細設計書です。
データベーススキーマ、テーブル定義、インデックス設計、マイグレーション戦略を定義します。

### 1.2 対象範囲

- RDS PostgreSQL 14.10
- データベーススキーマ（DDL）
- インデックス設計
- マイグレーション戦略（Knex.js使用）

---

## 2. RDS PostgreSQL 設計

### 2.1 インスタンス仕様

| 項目 | 設定値 | 理由 |
|------|--------|------|
| Engine | PostgreSQL 14.10 | 最新LTS、安定性重視 |
| Instance Class | db.t3.medium | 検証用、コスト重視 |
| CPU | 2 vCPU | 検証用の最小構成 |
| Memory | 4 GB | 検証用の最小構成 |
| Allocated Storage | 100 GB | 検証データ量想定（10万レコード） |
| Max Allocated Storage | 200 GB | Auto Scaling対応 |
| Storage Type | gp3 | 最新、コスト効率良 |
| IOPS | 3,000 IOPS（gp3デフォルト） | 検証用十分 |
| Throughput | 125 MiB/s（gp3デフォルト） | 検証用十分 |
| Multi-AZ | 有効 | 高可用性確保 |

### 2.2 ネットワーク設計

| 項目 | 設定値 | 理由 |
|------|--------|------|
| VPC | Service VPC (10.1.0.0/16) | Service Account内配置 |
| Subnet Group | Private Subnet 1a, 1c | Multi-AZ、インターネット非公開 |
| Security Group | RDS Security Group | ECSからのみアクセス許可（5432） |
| Publicly Accessible | false | セキュリティ確保 |

### 2.3 バックアップ・リカバリ設計

| 項目 | 設定値 | 理由 |
|------|--------|------|
| Backup Retention Period | 7日間 | 標準的な設定 |
| Backup Window | 19:00-20:00 UTC<br>(04:00-05:00 JST) | 日本時間深夜、トラフィック最小時 |
| Copy Tags to Snapshots | 有効 | タグ管理の一貫性 |
| Delete Automated Backups | 無効 | データ保護 |
| Deletion Protection | 無効 | 検証用のため削除可能 |

### 2.4 メンテナンス設定

| 項目 | 設定値 | 理由 |
|------|--------|------|
| Maintenance Window | Sun 20:00-21:00 UTC<br>(Sun 05:00-06:00 JST) | 日曜深夜、影響最小 |
| Auto Minor Version Upgrade | 有効 | セキュリティパッチ自動適用 |

### 2.5 監視・ログ設計

| 項目 | 設定値 | 理由 |
|------|--------|------|
| Enhanced Monitoring | 有効（60秒間隔） | OS metricsの詳細監視 |
| Performance Insights | 有効（7日保持） | クエリ性能分析 |
| CloudWatch Logs Export | postgresql, upgrade | ログ集約 |
| Log Retention | 30日間 | CloudWatch Logs保持期間 |

### 2.6 暗号化設計

| 項目 | 設定値 | 理由 |
|------|--------|------|
| Storage Encryption | 有効（KMS） | データ保護 |
| KMS Key | カスタマー管理キー | 暗号化キー管理 |
| Encryption at Rest | AES-256 | AWS標準 |
| Encryption in Transit | TLS 1.2以上 | 通信暗号化 |

---

## 3. データベーススキーマ設計

### 3.1 データベース・スキーマ構成

```
myapp_db (Database)
└── public (Schema)
    ├── users
    ├── products
    ├── orders
    └── order_items
```

**データベース名**: `myapp_db`
**スキーマ名**: `public`（PostgreSQLデフォルト）

### 3.2 ER図

```mermaid
erDiagram
    USERS ||--o{ ORDERS : "places"
    ORDERS ||--|{ ORDER_ITEMS : "contains"
    PRODUCTS ||--o{ ORDER_ITEMS : "includes"

    USERS {
        uuid user_id PK "主キー"
        varchar(255) email UK "ユニーク制約"
        varchar(255) name "氏名"
        timestamp created_at "作成日時"
        timestamp updated_at "更新日時"
    }

    ORDERS {
        uuid order_id PK "主キー"
        uuid user_id FK "外部キー"
        decimal(10,2) total_amount "合計金額"
        varchar(50) status "ステータス"
        timestamp order_date "注文日時"
        timestamp created_at "作成日時"
        timestamp updated_at "更新日時"
    }

    ORDER_ITEMS {
        uuid order_item_id PK "主キー"
        uuid order_id FK "外部キー"
        uuid product_id FK "外部キー"
        integer quantity "数量"
        decimal(10,2) unit_price "単価"
    }

    PRODUCTS {
        uuid product_id PK "主キー"
        varchar(255) product_name "商品名"
        decimal(10,2) price "価格"
        integer stock "在庫数"
        timestamp created_at "作成日時"
        timestamp updated_at "更新日時"
    }
```

---

## 4. テーブル定義

### 4.1 USERS（ユーザー）

**論理名**: ユーザー
**物理名**: `users`
**説明**: アプリケーション利用ユーザーの情報を管理

#### カラム定義

| カラム名 | 論理名 | データ型 | 桁数 | NULL | デフォルト値 | 制約 | 備考 |
|---------|-------|---------|------|------|------------|------|------|
| user_id | ユーザーID | UUID | - | NOT NULL | uuid_generate_v4() | PK | 主キー |
| email | メールアドレス | VARCHAR | 255 | NOT NULL | - | UNIQUE | ユニーク制約 |
| name | 氏名 | VARCHAR | 255 | NOT NULL | - | - | - |
| created_at | 作成日時 | TIMESTAMP | - | NOT NULL | CURRENT_TIMESTAMP | - | - |
| updated_at | 更新日時 | TIMESTAMP | - | NOT NULL | CURRENT_TIMESTAMP | - | - |

#### 制約

```sql
-- 主キー
PRIMARY KEY (user_id)

-- ユニーク制約
UNIQUE (email)

-- NOT NULL制約
NOT NULL: user_id, email, name, created_at, updated_at
```

#### インデックス

| インデックス名 | カラム | 種別 | 理由 |
|--------------|--------|------|------|
| users_pkey | user_id | PRIMARY KEY | 主キー |
| users_email_idx | email | UNIQUE INDEX | メールアドレス検索、一意性保証 |
| users_created_at_idx | created_at | INDEX | 日時範囲検索（ユーザー登録日別） |

#### DDL

```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE users (
    user_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) NOT NULL UNIQUE,
    name VARCHAR(255) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- インデックス作成
CREATE UNIQUE INDEX users_email_idx ON users(email);
CREATE INDEX users_created_at_idx ON users(created_at);

-- コメント
COMMENT ON TABLE users IS 'ユーザー情報';
COMMENT ON COLUMN users.user_id IS 'ユーザーID（主キー）';
COMMENT ON COLUMN users.email IS 'メールアドレス（ユニーク）';
COMMENT ON COLUMN users.name IS '氏名';
COMMENT ON COLUMN users.created_at IS '作成日時';
COMMENT ON COLUMN users.updated_at IS '更新日時';
```

---

### 4.2 PRODUCTS（商品）

**論理名**: 商品
**物理名**: `products`
**説明**: 販売商品の情報を管理

#### カラム定義

| カラム名 | 論理名 | データ型 | 桁数 | NULL | デフォルト値 | 制約 | 備考 |
|---------|-------|---------|------|------|------------|------|------|
| product_id | 商品ID | UUID | - | NOT NULL | uuid_generate_v4() | PK | 主キー |
| product_name | 商品名 | VARCHAR | 255 | NOT NULL | - | - | - |
| price | 価格 | DECIMAL | 10,2 | NOT NULL | 0 | CHECK (price >= 0) | 負の値不可 |
| stock | 在庫数 | INTEGER | - | NOT NULL | 0 | CHECK (stock >= 0) | 負の値不可 |
| created_at | 作成日時 | TIMESTAMP | - | NOT NULL | CURRENT_TIMESTAMP | - | - |
| updated_at | 更新日時 | TIMESTAMP | - | NOT NULL | CURRENT_TIMESTAMP | - | - |

#### 制約

```sql
-- 主キー
PRIMARY KEY (product_id)

-- CHECK制約
CHECK (price >= 0)  -- 価格は0以上
CHECK (stock >= 0)  -- 在庫は0以上

-- NOT NULL制約
NOT NULL: product_id, product_name, price, stock, created_at, updated_at
```

#### インデックス

| インデックス名 | カラム | 種別 | 理由 |
|--------------|--------|------|------|
| products_pkey | product_id | PRIMARY KEY | 主キー |
| products_product_name_idx | product_name | INDEX | 商品名検索 |
| products_price_idx | price | INDEX | 価格範囲検索 |

#### DDL

```sql
CREATE TABLE products (
    product_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_name VARCHAR(255) NOT NULL,
    price DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (price >= 0),
    stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- インデックス作成
CREATE INDEX products_product_name_idx ON products(product_name);
CREATE INDEX products_price_idx ON products(price);

-- コメント
COMMENT ON TABLE products IS '商品情報';
COMMENT ON COLUMN products.product_id IS '商品ID（主キー）';
COMMENT ON COLUMN products.product_name IS '商品名';
COMMENT ON COLUMN products.price IS '価格';
COMMENT ON COLUMN products.stock IS '在庫数';
COMMENT ON COLUMN products.created_at IS '作成日時';
COMMENT ON COLUMN products.updated_at IS '更新日時';
```

---

### 4.3 ORDERS（注文）

**論理名**: 注文
**物理名**: `orders`
**説明**: ユーザーの注文情報を管理

#### カラム定義

| カラム名 | 論理名 | データ型 | 桁数 | NULL | デフォルト値 | 制約 | 備考 |
|---------|-------|---------|------|------|------------|------|------|
| order_id | 注文ID | UUID | - | NOT NULL | uuid_generate_v4() | PK | 主キー |
| user_id | ユーザーID | UUID | - | NOT NULL | - | FK | 外部キー（users.user_id） |
| total_amount | 合計金額 | DECIMAL | 10,2 | NOT NULL | 0 | CHECK (total_amount >= 0) | 負の値不可 |
| status | ステータス | VARCHAR | 50 | NOT NULL | 'pending' | CHECK (status IN (...)) | pending/completed/cancelled |
| order_date | 注文日時 | TIMESTAMP | - | NOT NULL | CURRENT_TIMESTAMP | - | - |
| created_at | 作成日時 | TIMESTAMP | - | NOT NULL | CURRENT_TIMESTAMP | - | - |
| updated_at | 更新日時 | TIMESTAMP | - | NOT NULL | CURRENT_TIMESTAMP | - | - |

#### 制約

```sql
-- 主キー
PRIMARY KEY (order_id)

-- 外部キー
FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE RESTRICT ON UPDATE CASCADE

-- CHECK制約
CHECK (total_amount >= 0)
CHECK (status IN ('pending', 'completed', 'cancelled'))

-- NOT NULL制約
NOT NULL: order_id, user_id, total_amount, status, order_date, created_at, updated_at
```

#### インデックス

| インデックス名 | カラム | 種別 | 理由 |
|--------------|--------|------|------|
| orders_pkey | order_id | PRIMARY KEY | 主キー |
| orders_user_id_idx | user_id | INDEX | ユーザー別注文検索 |
| orders_order_date_idx | order_date | INDEX | 日時範囲検索 |
| orders_status_idx | status | INDEX | ステータス別検索 |
| orders_user_id_order_date_idx | user_id, order_date | INDEX | ユーザー別・日付別検索 |

#### DDL

```sql
CREATE TABLE orders (
    order_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (total_amount >= 0),
    status VARCHAR(50) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'completed', 'cancelled')),
    order_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE RESTRICT ON UPDATE CASCADE
);

-- インデックス作成
CREATE INDEX orders_user_id_idx ON orders(user_id);
CREATE INDEX orders_order_date_idx ON orders(order_date);
CREATE INDEX orders_status_idx ON orders(status);
CREATE INDEX orders_user_id_order_date_idx ON orders(user_id, order_date);

-- コメント
COMMENT ON TABLE orders IS '注文情報';
COMMENT ON COLUMN orders.order_id IS '注文ID（主キー）';
COMMENT ON COLUMN orders.user_id IS 'ユーザーID（外部キー）';
COMMENT ON COLUMN orders.total_amount IS '合計金額';
COMMENT ON COLUMN orders.status IS 'ステータス（pending/completed/cancelled）';
COMMENT ON COLUMN orders.order_date IS '注文日時';
COMMENT ON COLUMN orders.created_at IS '作成日時';
COMMENT ON COLUMN orders.updated_at IS '更新日時';
```

---

### 4.4 ORDER_ITEMS（注文明細）

**論理名**: 注文明細
**物理名**: `order_items`
**説明**: 注文に含まれる商品の明細情報を管理

#### カラム定義

| カラム名 | 論理名 | データ型 | 桁数 | NULL | デフォルト値 | 制約 | 備考 |
|---------|-------|---------|------|------|------------|------|------|
| order_item_id | 注文明細ID | UUID | - | NOT NULL | uuid_generate_v4() | PK | 主キー |
| order_id | 注文ID | UUID | - | NOT NULL | - | FK | 外部キー（orders.order_id） |
| product_id | 商品ID | UUID | - | NOT NULL | - | FK | 外部キー（products.product_id） |
| quantity | 数量 | INTEGER | - | NOT NULL | 1 | CHECK (quantity > 0) | 1以上 |
| unit_price | 単価 | DECIMAL | 10,2 | NOT NULL | 0 | CHECK (unit_price >= 0) | 負の値不可 |

#### 制約

```sql
-- 主キー
PRIMARY KEY (order_item_id)

-- 外部キー
FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE CASCADE ON UPDATE CASCADE
FOREIGN KEY (product_id) REFERENCES products(product_id) ON DELETE RESTRICT ON UPDATE CASCADE

-- CHECK制約
CHECK (quantity > 0)
CHECK (unit_price >= 0)

-- NOT NULL制約
NOT NULL: order_item_id, order_id, product_id, quantity, unit_price
```

#### インデックス

| インデックス名 | カラム | 種別 | 理由 |
|--------------|--------|------|------|
| order_items_pkey | order_item_id | PRIMARY KEY | 主キー |
| order_items_order_id_idx | order_id | INDEX | 注文別明細検索 |
| order_items_product_id_idx | product_id | INDEX | 商品別売上検索 |

#### DDL

```sql
CREATE TABLE order_items (
    order_item_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID NOT NULL,
    product_id UUID NOT NULL,
    quantity INTEGER NOT NULL DEFAULT 1 CHECK (quantity > 0),
    unit_price DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (unit_price >= 0),
    FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(product_id) ON DELETE RESTRICT ON UPDATE CASCADE
);

-- インデックス作成
CREATE INDEX order_items_order_id_idx ON order_items(order_id);
CREATE INDEX order_items_product_id_idx ON order_items(product_id);

-- コメント
COMMENT ON TABLE order_items IS '注文明細情報';
COMMENT ON COLUMN order_items.order_item_id IS '注文明細ID（主キー）';
COMMENT ON COLUMN order_items.order_id IS '注文ID（外部キー）';
COMMENT ON COLUMN order_items.product_id IS '商品ID（外部キー）';
COMMENT ON COLUMN order_items.quantity IS '数量';
COMMENT ON COLUMN order_items.unit_price IS '単価';
```

---

## 5. インデックス設計

### 5.1 インデックス戦略

**基本方針**:
- 主キーは自動的にインデックス作成（PRIMARY KEY）
- 外部キーには明示的にインデックス作成（JOIN性能向上）
- 検索頻度の高いカラムにインデックス作成
- 複合インデックスは検索パターンに応じて作成

### 5.2 インデックス一覧

| テーブル | インデックス名 | カラム | 種別 | Cardinality | 理由 |
|---------|--------------|--------|------|------------|------|
| users | users_pkey | user_id | PRIMARY | 高 | 主キー |
| users | users_email_idx | email | UNIQUE | 高 | メールアドレス検索、一意性 |
| users | users_created_at_idx | created_at | INDEX | 中 | 日時範囲検索 |
| products | products_pkey | product_id | PRIMARY | 高 | 主キー |
| products | products_product_name_idx | product_name | INDEX | 高 | 商品名検索 |
| products | products_price_idx | price | INDEX | 中 | 価格範囲検索 |
| orders | orders_pkey | order_id | PRIMARY | 高 | 主キー |
| orders | orders_user_id_idx | user_id | INDEX | 中 | ユーザー別注文検索 |
| orders | orders_order_date_idx | order_date | INDEX | 中 | 日時範囲検索 |
| orders | orders_status_idx | status | INDEX | 低 | ステータス別検索 |
| orders | orders_user_id_order_date_idx | user_id, order_date | INDEX | 中 | 複合検索 |
| order_items | order_items_pkey | order_item_id | PRIMARY | 高 | 主キー |
| order_items | order_items_order_id_idx | order_id | INDEX | 中 | 注文別明細検索 |
| order_items | order_items_product_id_idx | product_id | INDEX | 中 | 商品別売上検索 |

### 5.3 複合インデックスの使用パターン

**orders_user_id_order_date_idx (user_id, order_date)**

使用されるクエリ例:
```sql
-- ユーザー別・日付範囲での注文検索
SELECT * FROM orders
WHERE user_id = 'xxx-xxx-xxx'
  AND order_date BETWEEN '2025-01-01' AND '2025-12-31';

-- ユーザー別・最新注文取得
SELECT * FROM orders
WHERE user_id = 'xxx-xxx-xxx'
ORDER BY order_date DESC
LIMIT 10;
```

---

## 6. データライフサイクル

### 6.1 データ保持期間

| データ種別 | 保持期間 | アーカイブ方式 | 削除方式 | 備考 |
|-----------|----------|---------------|----------|------|
| ユーザーデータ | 無期限 | - | 論理削除 | 検証用データ |
| 商品データ | 無期限 | - | 論理削除 | - |
| 注文データ | 1年間 | S3エクスポート | 物理削除 | 1年経過後アーカイブ |
| 注文明細データ | 1年間 | S3エクスポート | 物理削除（CASCADE） | 注文削除時に自動削除 |

### 6.2 論理削除 vs 物理削除

**論理削除対象**:
- users, products

**物理削除対象**:
- orders, order_items（1年経過後）

**論理削除実装案（将来拡張）**:
```sql
-- usersテーブルに deleted_at カラム追加
ALTER TABLE users ADD COLUMN deleted_at TIMESTAMP NULL;

-- 論理削除
UPDATE users SET deleted_at = CURRENT_TIMESTAMP WHERE user_id = 'xxx';

-- 有効なユーザーのみ取得
SELECT * FROM users WHERE deleted_at IS NULL;
```

---

## 7. 初期データ投入

### 7.1 初期データ戦略

**検証用の初期データ**:
- ユーザー: 10件
- 商品: 20件
- 注文: 100件
- 注文明細: 300件

### 7.2 初期データSQL

```sql
-- ユーザー初期データ（10件）
INSERT INTO users (email, name) VALUES
('user1@example.com', 'テストユーザー1'),
('user2@example.com', 'テストユーザー2'),
('user3@example.com', 'テストユーザー3'),
('user4@example.com', 'テストユーザー4'),
('user5@example.com', 'テストユーザー5'),
('user6@example.com', 'テストユーザー6'),
('user7@example.com', 'テストユーザー7'),
('user8@example.com', 'テストユーザー8'),
('user9@example.com', 'テストユーザー9'),
('user10@example.com', 'テストユーザー10');

-- 商品初期データ（20件）
INSERT INTO products (product_name, price, stock) VALUES
('商品A', 1000.00, 100),
('商品B', 2000.00, 50),
('商品C', 3000.00, 30),
('商品D', 1500.00, 80),
('商品E', 2500.00, 60),
('商品F', 500.00, 200),
('商品G', 4000.00, 20),
('商品H', 1200.00, 90),
('商品I', 1800.00, 70),
('商品J', 3500.00, 40),
('商品K', 800.00, 150),
('商品L', 2200.00, 55),
('商品M', 2800.00, 45),
('商品N', 1100.00, 95),
('商品O', 1900.00, 65),
('商品P', 3200.00, 35),
('商品Q', 700.00, 180),
('商品R', 2600.00, 50),
('商品S', 3800.00, 25),
('商品T', 1300.00, 85);
```

---

## 8. マイグレーション戦略

### 8.1 マイグレーションツール選定

**採用ツール**: Knex.js Migrations

**選定理由**:
- Node.jsアプリケーションとの親和性
- トランザクション対応
- Up/Downマイグレーション
- バージョン管理

### 8.2 マイグレーションファイル構成

```
app/shared/db/migrations/
├── 20251020120000_create_users_table.js
├── 20251020120100_create_products_table.js
├── 20251020120200_create_orders_table.js
├── 20251020120300_create_order_items_table.js
└── 20251020120400_add_initial_data.js
```

### 8.3 マイグレーションファイル例

**20251020120000_create_users_table.js**:

```javascript
exports.up = function(knex) {
  return knex.schema.createTable('users', function(table) {
    table.uuid('user_id').primary().defaultTo(knex.raw('uuid_generate_v4()'));
    table.string('email', 255).notNullable().unique();
    table.string('name', 255).notNullable();
    table.timestamp('created_at').notNullable().defaultTo(knex.fn.now());
    table.timestamp('updated_at').notNullable().defaultTo(knex.fn.now());

    // インデックス
    table.index('email', 'users_email_idx');
    table.index('created_at', 'users_created_at_idx');

    // コメント
    table.comment('ユーザー情報');
  });
};

exports.down = function(knex) {
  return knex.schema.dropTable('users');
};
```

### 8.4 マイグレーション実行手順

```bash
# マイグレーション実行（最新まで）
npm run migrate:latest

# マイグレーションロールバック（1つ前に戻す）
npm run migrate:rollback

# マイグレーション状態確認
npm run migrate:status
```

**package.json**:
```json
{
  "scripts": {
    "migrate:latest": "knex migrate:latest",
    "migrate:rollback": "knex migrate:rollback",
    "migrate:status": "knex migrate:status"
  }
}
```

---

## 9. パフォーマンス最適化

### 9.1 クエリ最適化

**よく使われるクエリのEXPLAIN分析**:

```sql
-- ユーザー別注文一覧（インデックス使用確認）
EXPLAIN ANALYZE
SELECT o.*, u.name
FROM orders o
JOIN users u ON o.user_id = u.user_id
WHERE u.user_id = 'xxx-xxx-xxx'
ORDER BY o.order_date DESC;

-- 商品別売上集計（インデックス使用確認）
EXPLAIN ANALYZE
SELECT p.product_name, SUM(oi.quantity * oi.unit_price) AS total_sales
FROM order_items oi
JOIN products p ON oi.product_id = p.product_id
GROUP BY p.product_id, p.product_name
ORDER BY total_sales DESC;
```

### 9.2 接続プール設定

**Node.js pg接続プール**:

```javascript
const { Pool } = require('pg');

const pool = new Pool({
  host: process.env.DB_HOST,
  port: process.env.DB_PORT,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  max: 20,                     // 最大接続数
  idleTimeoutMillis: 30000,    // アイドル接続タイムアウト
  connectionTimeoutMillis: 2000, // 接続タイムアウト
});
```

---

## 10. 実装方針 ⭐⭐⭐

### 10.1 マイグレーションファイル構成

**ディレクトリ構成**:

```
app/shared/db/
├── migrations/                                 # マイグレーションファイル
│   ├── 20251020120000_create_users_table.js   # 推定: 50行
│   ├── 20251020120100_create_products_table.js # 推定: 50行
│   ├── 20251020120200_create_orders_table.js   # 推定: 60行
│   ├── 20251020120300_create_order_items_table.js # 推定: 50行
│   └── 20251020120400_add_initial_data.js      # 推定: 100行
├── seeds/                                      # シードデータ
│   └── dev/
│       └── 01_sample_data.js                   # 推定: 200行
├── connection.js                               # DB接続管理（推定: 50行）
└── knexfile.js                                 # Knex設定（推定: 80行）
```

**推定合計**: 約640行

### 10.2 技術標準の適用

**参照標準**: `.claude/docs/40_standards/41_common.md`

| 技術標準項目 | 適用状況 | 詳細 |
|------------|---------|------|
| **命名規則** | ✅ 適用 | テーブル名: snake_case、カラム名: snake_case |
| **コメント** | ✅ 適用 | 各テーブル・カラムにCOMMENT追加 |
| **トランザクション** | ✅ 適用 | マイグレーション時にトランザクション使用 |
| **エラーハンドリング** | ✅ 適用 | マイグレーション失敗時にロールバック |

### 10.3 実装時の注意事項

**1. UUID Extension有効化**

```sql
-- 最初のマイグレーションで必ず実行
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
```

**2. Foreign Key制約の順序**

テーブル作成順序を守る:
1. users（親テーブル）
2. products（親テーブル）
3. orders（usersに依存）
4. order_items（orders, productsに依存）

**3. インデックス作成タイミング**

テーブル作成と同時にインデックス作成（マイグレーションファイル内）

**4. 初期データ投入**

マイグレーション完了後、Knex Seedsで投入

### 10.4 実装チェックリスト

実装前:
- [ ] 設計書のER図を確認
- [ ] テーブル依存関係を理解
- [ ] マイグレーションツール（Knex.js）の使い方を確認

実装中:
- [ ] UUID Extension有効化
- [ ] テーブル作成順序を守る
- [ ] Foreign Key制約を正しく設定
- [ ] インデックスを作成
- [ ] COMMENTを追加

実装後:
- [ ] マイグレーション実行確認
- [ ] ロールバック動作確認
- [ ] 初期データ投入確認
- [ ] EXPLAIN ANALYZEでクエリ性能確認

---

## 付録

### A. 変更履歴

| 日付 | 版数 | 変更内容 | 承認者 |
|------|------|----------|--------|
| 2025-10-21 | 1.0 | 初版作成（実装方針含む） | - |

### B. 参考資料

- PostgreSQL 14公式ドキュメント: https://www.postgresql.org/docs/14/
- Knex.js公式ドキュメント: https://knexjs.org/
- UUID Best Practices: https://www.postgresql.org/docs/14/datatype-uuid.html
