# AI開発ファシリテーター 要件定義書

## 1. 概要

### 1.1 背景
開発プロセスにおいて、AIが技術標準を守らず、スパゲッティコードを生成したり、本番環境に直接操作を行うなどの問題が発生している。また、非エンジニアがシステム開発に参加する際、適切なプロセスとドキュメントがないため、品質や安全性に課題がある。

### 1.2 目的
自然言語での対話を通じて、標準化された開発プロセスをAIがファシリテートし、エンジニア・非エンジニアを問わず、誰でも高品質で安全なシステム開発を実現できる環境を提供する。

### 1.3 スコープ

#### Phase 1（初期実装）
- `.claude`設定ファイルによるローカル完結の仕組み
- 全開発フェーズ対応（企画→要件定義→設計→実装→テスト→デプロイ）
- 汎用的なシステム開発に対応（Webアプリ、API、インフラ、バッチ処理等）
- **初期検証ユースケース：AWS IaCプロジェクト**
- 単一プロジェクトでの運用

#### Phase 2以降（将来）
- MCP連携（Slack、Notion、GitHub等）
- 複数プロジェクト並行管理
- 既存インフラの解析・ドキュメント化
- 運用監視と自動復旧

---

## 2. ステークホルダー

### 2.1 主要ユーザー
1. **初期ユーザー（Phase 1）**
   - インフラエンジニア（AWS IaC構築・改修）
   - 本システムを実際に使用して検証

2. **展開先ユーザー（Phase 2）**
   - 周囲のエンジニア
   - 開発チーム全体

3. **最終ターゲット（Phase 3）**
   - 非エンジニアの事業会社担当者
   - 個人の起業家・アイデア保有者
   - 開発経験の浅いエンジニア
   - コンサルティングツールとしての活用

### 2.2 利用シーン

本システムは以下のような様々なシステム開発に対応：

1. **インフラ構築（IaC）**
   - クラウドインフラの構築・改修
   - 要件定義から設計、コード生成、デプロイまで
   - **Phase 1 検証対象：AWS（CloudFormation/Terraform）**
   - 将来的にGCP、Azure等にも対応

2. **Webアプリケーション開発**
   - フロントエンド（React、Vue、Angular等）
   - バックエンド（Node.js、Python、Java等）
   - フルスタック開発

3. **APIサーバー構築**
   - RESTful API
   - GraphQL API
   - マイクロサービス

4. **バッチ処理システム**
   - データ処理パイプライン
   - 定期実行ジョブ
   - ETL処理

5. **モバイルアプリ開発**（将来対応）
   - iOS、Android
   - クロスプラットフォーム

---

## 3. 機能要件

### 3.1 コミュニケーション機能

#### 3.1.1 対話型ヒアリング
- **一問一答形式**
  - 複数質問を同時にしない（ユーザーが疲れない）
  - 回答に応じて次の質問を選択
  - 会話の自然な流れを重視

- **段階的な情報収集**
  1. ビジネス背景（最優先）
     - 業種・業態
     - 現在の課題
     - なぜ今開発が必要なのか
     - レガシーからの移行 or 新規開発
  2. 技術要件（背景理解後）
     - システム構成
     - 規模・性能要件
     - セキュリティ・コンプライアンス

- **認識齟齬の防止**
  - 各フェーズ終了時に必ず確認
  - ビジュアル資料を活用
  - 曖昧な回答には追加質問
  - 決定事項の明示的な確認

#### 3.1.2 提案機能
- **「もっといい提案」の提供**
  - ユーザーの要望を否定しない
  - より良い選択肢を提示
  - 提案タイミング：会話の自然な切れ目、ユーザーの温度感を見て判断

- **プロとしての視点**
  - コスト最適化の提案
  - 将来の拡張性を考慮した設計提案
  - セキュリティリスクと対策の提示
  - パフォーマンス改善の提案

- **説明責任**
  - 提案理由を明確に説明
  - メリット・デメリットを提示
  - 非エンジニアにも分かる言葉で説明

#### 3.1.3 学習機会の提供
- 生成したコードの説明
- ベストプラクティスの解説
- 技術的判断の根拠を提示
- ユーザーが徐々に自力で書けるようになる支援

### 3.2 ドキュメント生成機能

#### 3.2.1 生成方針
- **受託開発納品レベルの品質**
- **フェーズごとの自動生成**
- **AIがプロアクティブに判断**して必要なドキュメントを生成

#### 3.2.2 ドキュメントの種類

##### Phase 1で対応
1. **企画/提案書**
   - ビジョン、目的、ROI
   - 背景と課題
   - 成功基準

2. **要件定義書**
   - ビジネス背景
   - 機能要件
   - 非機能要件（性能、セキュリティ、可用性）
   - 制約条件

3. **基本設計書**
   - システム全体のアーキテクチャ
   - 技術スタック選定
   - インフラ構成

4. **詳細設計書**
   - 機能レベルの詳細仕様
   - API設計
   - データベース設計
   - セキュリティ設計

5. **実装ドキュメント**
   - コーディング規約
   - ディレクトリ構造
   - セットアップ手順

6. **テスト計画書・結果報告書**
   - テスト戦略
   - テストケース
   - テスト結果

7. **デプロイ手順書**
   - 環境構築手順
   - デプロイ手順
   - ロールバック手順

8. **CI/CD設計書**
   - パイプライン設計
   - 環境戦略（dev/stg/prod）
   - ブランチ戦略
   - ロールバック戦略

#### 3.2.3 ビジュアル資料の生成

##### 対応形式
- **Mermaid** - テキストベースの図（最優先）
  - システム構成図
  - CI/CDパイプライン図
  - ER図
  - シーケンス図
  - フロー図

- **DrawIO** - .drawio形式（将来対応）
- **PlantUML** - UML図（将来対応）
- **Figma連携** - UI/UXデザイン（ユーザー作成の共有）

##### AWS IaCで最優先の図
1. **システム構成図**
   - AWSサービスの配置
   - VPC、サブネット構成
   - セキュリティグループ
   - ロードバランサー、AutoScaling等

2. **CI/CDパイプライン図**
   - ソースコード管理（GitHub）
   - ビルド・テストプロセス
   - デプロイフロー
   - 承認フロー

3. **ネットワーク図**
   - VPC設計
   - サブネット分割
   - ルーティング
   - インターネットゲートウェイ、NATゲートウェイ

#### 3.2.4 ユーザー確認フロー
1. AIがヒアリングしながら情報収集
2. フェーズ終了時にドキュメント生成
3. **ユーザーに確認依頼**
   - ドキュメントの内容確認
   - 収集した情報の充足度確認
   - 次フェーズに進んで良いかの確認
4. 承認されたら次フェーズへ遷移
5. 承認されなかった場合
   - 追加ヒアリング実施
   - ドキュメント再生成
   - 再度確認依頼

### 3.3 タスク・課題・進捗管理機能

#### 3.3.1 タスク管理
- やるべきことの管理と追跡
- フェーズごとのタスク一覧
- タスクの優先順位付け
- 完了状況の記録

#### 3.3.2 課題管理
- 問題・リスクの把握
- 対応策の管理
- 課題の優先順位
- 解決状況の追跡

#### 3.3.3 進捗管理
- フェーズごとの進捗状況の可視化
- 全体進捗率の表示
- マイルストーン管理
- スケジュール遅延の検知

#### 3.3.4 未決定事項の追跡
- 決定保留事項の一覧
- 決定期限の管理
- 影響範囲の把握

### 3.4 コード生成機能

#### 3.4.1 対応技術領域（Phase 1）
- **AWS IaC** - CloudFormation または Terraform
- **CI/CD** - GitHub Actions
- **フロントエンド** - React/Vue等（基本対応）
- **バックエンド** - Node.js/Python等（基本対応）
- **データベース** - RDS、DynamoDB等

#### 3.4.2 技術標準・コード規約の適用

##### 4つの基本方針
1. **品質確保**
   - 保守可能なコード構造
   - 適切なモジュール分割
   - 技術的負債の最小化

2. **安全性確保**
   - 本番環境への直接操作禁止
   - 機密情報の適切な管理
   - 権限の最小化原則

3. **一貫性の維持**
   - コーディング規約の統一
   - 命名規則の標準化
   - ディレクトリ構造の統一

4. **ベストプラクティスの適用**
   - 各技術領域の推奨パターン
   - セキュリティ対策の標準化
   - パフォーマンスの最適化

##### 技術領域ごとの重点項目

**共通項目（全技術領域）**
1. **モジュール/コンポーネント分割**
   - 適切な粒度での分割
   - 再利用可能な設計
   - 責任の明確化

2. **環境差分の管理**
   - dev/stg/prodの差分を見やすく整理
   - 設定ファイルの構造化
   - シークレット情報の分離

3. **直感的な構成**
   - 誰が見ても分かるディレクトリ構造
   - 自己説明的な命名
   - 適切なコメント

**IaC（インフラ）特有**
- ネストテンプレート/モジュールの活用
- ステートファイル管理
- リソース命名規則

**Webアプリケーション特有**
- コンポーネント設計
- 状態管理の方針
- API連携のパターン

**バックエンド特有**
- レイヤーアーキテクチャ
- エラーハンドリング戦略
- ロギング・監視

#### 3.4.3 コード説明と学習支援
- 生成したコードの各部分の説明
- なぜこう書くのかの根拠
- ベストプラクティスの解説
- 改善ポイントの提示

### 3.5 デプロイ機能

#### 3.5.1 デプロイフロー（安全性重視）
1. **Dry-run（差分確認）**
   - 変更内容の表示
   - 影響範囲の確認
   - リスクの提示

2. **ユーザー承認**
   - 変更内容の確認
   - 実行タイミングの決定

3. **本番実行**
   - デプロイ実行
   - リアルタイムログ表示
   - エラーハンドリング

#### 3.5.2 デプロイ方法

**CI/CDツール（推奨）**
- **GitHub Actions** - 推奨
  - ブランチプッシュでトリガー
  - Pull Request でのレビュー
  - マージ後の自動デプロイ
- GitLab CI/CD
- CircleCI
- Jenkins

**手動実行（開発時・緊急時）**
- IaC：AWS CLI、Terraform CLI、gcloud等
- Webアプリ：ビルド→デプロイコマンド生成
- コマンド生成後、実行はユーザーが手動で

#### 3.5.3 環境戦略
- **環境分離**
  - dev（開発環境）
  - stg（ステージング環境）
  - prod（本番環境）

- **ブランチ戦略**
  - feature/* - 機能開発
  - develop - 開発統合
  - staging - ステージング
  - main - 本番

- **デプロイ順序**
  1. feature → develop → dev環境
  2. develop → staging → stg環境
  3. staging → main → prod環境（承認必須）

#### 3.5.4 ロールバック戦略
- **失敗検知**
  - デプロイエラーの自動検知
  - ヘルスチェック失敗の検知
  - アラート通知

- **ロールバック手順**
  1. 前バージョンの特定
  2. ロールバックコマンド生成
  3. ユーザー確認
  4. ロールバック実行

- **バックアップ戦略**
  - IaCの状態ファイル管理
  - データベースバックアップ
  - 設定ファイルのバージョン管理

### 3.6 エラーハンドリング・デバッグ支援

#### 3.6.1 エラーログ解析
- ログの自動収集
- エラーメッセージの解析
- 原因の特定
- 関連する設定・コードの特定

#### 3.6.2 修正方法の提案
- 具体的な修正手順の提示
- 修正コードの生成
- 複数の解決策の提案
- リスクと影響範囲の説明

#### 3.6.3 よくあるエラーの事前チェック
- デプロイ前のバリデーション
- 設定ミスの検出
- 権限不足の確認
- リソース制限のチェック

---

## 4. 非機能要件

### 4.1 パフォーマンス
- ドキュメント生成：30秒以内
- コード生成：1分以内
- エラー解析：10秒以内

### 4.2 ユーザビリティ
- **対話の自然さ**
  - 日本語での自然な対話
  - 適切な敬語の使用
  - 専門用語は説明を添える

- **わかりやすさ**
  - 非エンジニアでも理解できる説明
  - ビジュアル資料を活用
  - 段階的な情報提示

- **ストレスの軽減**
  - 一問一答形式
  - 回答の強制をしない
  - 後から変更可能

### 4.3 セキュリティ
- **機密情報管理**
  - AWSクレデンシャルの安全な管理
  - シークレット情報のハードコード禁止
  - 環境変数の適切な使用

- **本番環境保護**
  - 直接操作の禁止
  - dry-run必須
  - 承認フロー

- **権限管理**
  - 最小権限の原則
  - IAMロールの適切な設定
  - アクセス制御

### 4.4 保守性
- **コードの可読性**
  - 適切なコメント
  - 自己説明的な命名
  - モジュール化

- **ドキュメントの更新**
  - 変更時の自動更新
  - バージョン管理
  - 変更履歴の記録

- **拡張性**
  - 新しい技術への対応
  - プラグイン機構
  - カスタマイズ可能

### 4.5 可用性
- **エラー復旧**
  - エラー時の自動リカバリー
  - ロールバック機能
  - 詳細なログ記録

- **状態管理**
  - プロジェクト状態の永続化
  - 中断・再開の対応
  - 履歴の保存

---

## 5. 制約条件

### 5.1 技術的制約
- **Phase 1**
  - `.claude`設定ファイルのみで動作
  - ローカル環境で完結
  - Claude Codeの機能範囲内

- **外部ツール連携**
  - Phase 1ではMCP連携なし
  - Phase 2以降で段階的に追加

### 5.2 対応範囲の制約（Phase 1）
- **単一プロジェクトのみ**
  - 複数プロジェクト並行管理は Phase 2

- **既存インフラ解析**
  - Phase 2 以降で対応

### 5.3 予算制約
- Phase 1 は最小限の実装
- 実用性検証後に Phase 2 へ

### 5.4 期間制約
- Phase 1 の早期実用化を優先
- 初期検証ユースケース（AWS IaC）での実運用で検証
- 検証完了後、他の技術領域へ展開

---

## 6. 成功基準

### 6.1 Phase 1 の成功基準

1. **初期検証プロジェクト（AWS IaC）での実用**
   - 要件定義からデプロイまで完遂
   - 納品レベルのドキュメント生成
   - 安全なデプロイフロー
   - 他の技術領域にも適用可能な汎用性を確認

2. **コード品質**
   - スパゲッティコードにならない
   - 技術標準に準拠
   - 保守可能な構造
   - 技術領域に関わらず一貫した品質

3. **ユーザー満足度**
   - 対話がスムーズ
   - 疲れない（一問一答形式）
   - 学びがある（技術的成長）
   - エンジニア・非エンジニア両方が使える

4. **安全性**
   - 本番環境への誤操作ゼロ
   - シークレット漏洩ゼロ
   - dry-run必須の徹底

### 6.2 Phase 2 以降の目標
- 周囲のエンジニアへの展開
- MCP連携の実現
- コンサルツールとしての活用

---

## 7. 用語集

| 用語 | 説明 |
|------|------|
| IaC | Infrastructure as Code - インフラをコードで管理 |
| Dry-run | 実際には実行せず、変更内容のみ確認する機能 |
| ネストテンプレート | CloudFormationで、テンプレートを分割して管理する手法 |
| ロールバック | デプロイ失敗時に前のバージョンに戻すこと |
| MCP | Model Context Protocol - 外部ツール連携のプロトコル |

---

## 8. 付録

### 8.1 ヒアリング時の質問例

#### 8.1.1 共通質問（全プロジェクト）

**ビジネス背景**
1. どのような業種・業態ですか？
2. 現在どのような課題がありますか？
3. なぜ今この開発が必要ですか？
4. レガシーシステムからの移行ですか、新規開発ですか？

**システム要件**
5. どのようなシステム・アプリケーションを作りますか？
6. 想定するユーザー数・規模は？
7. 可用性の要件は？（ダウンタイム許容度）
8. セキュリティ要件は？（コンプライアンス等）
9. 予算・期間の制約はありますか？

**技術選定**
10. 使用したい技術・フレームワークはありますか？
11. 制約事項はありますか？（使えない技術、必須の技術等）
12. 既存システムとの連携はありますか？

#### 8.1.2 技術領域別の追加質問

**インフラ構築（IaC）の場合**
- IaCツールの希望は？（CloudFormation/Terraform/CDK等）
- クラウドプロバイダーは？（AWS/GCP/Azure）
- 既存インフラとの統合方法は？
- リージョン・AZ構成の要件は？

**Webアプリケーション開発の場合**
- フロントエンド/バックエンド/フルスタック？
- SPAですか、SSRですか？
- 認証方式は？（OAuth、JWT等）
- データの永続化は必要ですか？

**API開発の場合**
- RESTful API/GraphQL/gRPC？
- 認証・認可の方式は？
- レート制限は必要ですか？
- APIドキュメントの自動生成は必要ですか？

**バッチ処理の場合**
- 実行頻度は？（リアルタイム/定期実行/イベント駆動）
- データソースは？
- エラー時のリトライ戦略は？
- 処理結果の通知は必要ですか？

---

## 9. 承認

本要件定義書の内容を確認し、次のフェーズ（設計）に進むことに同意します。

- 承認日：________
- 承認者：________